(* ::Package:: *)

(********************************************************************)
(*                                                                  *)
(* :Title:       OctagonalTilingCP                                  *)
(*                                                                  *)
(* :Authors:     Uwe Grimm                                          *)
(*                                                                  *)
(* :Context:     AperiodicTilings`OctagonalTilingCP`                *)
(*                                                                  *)
(* :Version:     1.01                                               *)
(*                                                                  *)
(* :Date:        January 12, 2005                                   *)
(*                                                                  *)
(* :Summary:     This package is part of a collection of            *)
(*               Mathematica programs that were originally          *)
(*               developed for a HERAEUS summer school on           *)
(*               quasicrystals held at Chemnitz University          *) 
(*               of Technology in September 1997. For more          *)
(*               information, we refer to the proceedings:          *)
(*                                                                  *)
(*               J.-B. Suck, M. Schreiber, P. Haeussler,            *)
(*               Quasicrystals: An Introduction to structure,       *)
(*               physical properties, and applications,             *)
(*               Springer, Berlin (2002)                            *)
(*                                                                  *)
(* :References:  R. Ammann, B. Gruenbaum, and G.C. Shephard,        *)
(*               Aperiodic tiles,                                   *)
(*               Discrete Comput. Geom. 8 (1992) 1-25               *)
(*                                                                  *)
(*               M. Duneau, R. Mosseri, and C. Oguey,               *)
(*               Approximants of quasiperiodic structures           *)
(*               generated by the inflation mapping,                *)
(*               J. Phys. A: Math. Gen. 22 (1989) 4549-4564         *)
(*                                                                  *)
(*               B. Gruenbaum and G.C. Shephard,                    *)
(*               Tilings and Patterns,                              *)
(*               W.H. Freeman, New York (1987),                     *)
(*               Figure 10.4.14 on page 556                         *)
(*                                                                  *)
(* :Description: This package deals with two different ways of      *)
(*               constructing the octagonal tiling, also known      *)
(*               as the Ammann-Beenker tiling. This tiling          *)
(*               possesses an eightfold rotational symmetry and     *)
(*               contains two different kinds of tiles, squares     *)
(*               and 45-degree rhombs.                              *) 
(*                                                                  *)
(*               The first method employed here is the inflation    *)
(*               procedure. The main routine OctagonalInflation     *)
(*               inflates the tiling, preserving the lengths of     *)
(*               edges in the tiling. In this part of this          *)
(*               the squares of the tiling are treated as two       *)
(*               triangles in order to simplify the inflation       *)
(*               rules. In the routine PlotOctagonalTiling          *)
(*               that produces a graphical version of the tiling    *)
(*               obtained from OctagonalInflation, one can choose   *)
(*               whether the triangles are shown or not. Other      *)
(*               optional choices include colors of edges and       *) 
(*               tiles, and edge and vertex decorations that        *)
(*               encode the matching rules for the octagonal        *)
(*               tiling. The inflation procedure can nicely be      *)
(*               seen in a plot made with OctagonalInflationPlot,   *)
(*               which displays a tiling and its inflation next     *)
(*               to each other. In addition, some initial patches   *)
(*               of the tiling are provided, such as SquarePatch    *)
(*               or OctagonalPatch, and CutOctagonalPatch can be    *)
(*               used to cut out a smaller patch from a tiling.     *)
(*               The connectivity of the tilings as a graph can     *)
(*               also be obtained in matrix form with the command   *)
(*               OctagonalAdjacencyMatrix.                          *) 
(*                                                                  *)
(*               The second method used in this package is the      *)
(*               standard cut-and-project method, in this case      *) 
(*               from the four-dimensional hypercubic lattice.      *)      
(*               The acceptance domain is the projection of the     *)
(*               four-dimensional hypercube, the projections to     *)
(*               parallel and perpendicular space can be viewed     *)
(*               with the commands PlotCubeParallelProjection and   *)
(*               PlotCubeOrthogonalProjection. Actually, in this    *)
(*               particular case the projections turn out to be     *)
(*               the same, and the acceptance domain is a regular   *)
(*               octagon. A patch of the tiling is produced by      *)
(*               the command OctagonalProjectionTiling, starting    *)
(*               from an initial point of the hypercubic lattice    *)
(*               and considering all those lattice points that can  *)  
(*               be reached in a given number of steps along the    *)
(*               basic lattice vectors. The resulting tiling in     *)
(*               parallel space and the distribution of points in   *)
(*               the acceptance domain in perpendicular space can   *)
(*               be viewed with PlotParallelProjection and with     *)
(*               PlotOrthogonalProjection, respectively.            *)
(*                                                                  *)
(* :Notes:       While most calculations involve only integer       *)
(*               numbers, some of the checks are done using         *)
(*               real numbers. In this case, in order to decide     *)
(*               whether a real number equals zero or not, we       *)
(*               compare with the internal variable                 *)
(*               NumericalAccuracy which by default we chose to     *)
(*               to be two orders of magnitude larger than the      *)
(*               $MachinePrecision. If any problems occurs due      *)
(*               numerical inaccuracies, the working precision      *)
(*               NumericalPrecision should be adjusted accordingly  *)
(*               using the command SetNumericalPrecision.           *)
(*                                                                  *)
(*               Due to the different construction principles, the  *)
(*               tilings produced by inflation and by projection    *)
(*               are stored in very different ways. Therefore, it   *)
(*               is not easily possible to transfer from one        *)
(*               description to the other. This is also the reason  *)
(*               why two separate routines for the graphical        *)
(*               representation of the tilings have been included   *)
(*               in this package.                                   *)
(*                                                                  *)
(* :Changes:     January 12, 2005 [UG] Version 1.0 -> 1.01:         *)
(*               -> just minor changes in the documentation         *)
(*                                                                  *)
(* :Bugs:        No bugs known so far.                              *)
(*               Please send bug reports to:                        *)
(*               u.grimm@physics.org                                *)
(*                                                                  *)
(* :Copyright:   This package may be copied and redistributed       *) 
(*               freely by anyone, but it may not be sold           *)
(*               commercially. Any changes to the original code     *)
(*               should be documented, or preferably suggested      *)
(*               to the authors of this package to make useful      *)
(*               changes or additions available to the community.   *)
(*                                                                  *)
(* :Disclaimer:  No guarantee for correctness of the program and    *)
(*               results obtained with the program is given. Use    *)
(*               at your own risk!                                  *)
(*                                                                  *)
(********************************************************************)

BeginPackage["AperiodicTilings`OctagonalTilingCP`",{"EuclideanAlgorithmZSqrt2`"}]

(********************************************************************)
(*                                                                  *)
(*              Usage messages for exported functions               *)
(*                                                                  *)
(********************************************************************)


PlotCubeParallelProjection::usage =
"PlotCubeParallelProjection[linethickness,psize,pointcolor,linecolor]
show the projection of the four-dimensional hypercube to parallel
space. The arguments are optional, linethickness determines the width
of lines (default value 1/100), psize the point size (default value 0,
i.e., no points), pointcolor and linecolor the colors of points
(default blue) and lines (default black), respectively. Colors can be
specified either by a single number num, resulting in GrayLevel[num],
or by a list of three of four numbers, in which cases the corresponding 
RGB or CMYK color is used, respectively."

PlotCubeOrthogonalProjection::usage =
"PlotCubeOrthogonalProjection[linethickness,psize,pointcolor,linecolor]
show the projection of the four-dimensional hypercube to orthogonal
space. The arguments are optional, linethickness determines the width
of lines (default value 1/100), psize the point size (default value 0,
i.e., no points), pointcolor and linecolor the colors of points
(default blue) and lines (default black), respectively. Colors can be
specified either by a single number num, resulting in GrayLevel[num],
or by a list of three of four numbers, in which cases the corresponding 
RGB or CMYK color is used, respectively."

OctagonalProjectionTiling::usage =
"OctagonalProjectionTiling[initpoint,maxstep] produces a projection
tiling, starting from the initial point initpoint in the
four-dimensional hypercubic lattice and considering all those points
of the lattice that can be reached withing maxstep steps along the
basic lattice vectors. The resulting tiling is returned as a list of
two lists. The first list contains the four-dimensional integer
coordinates of the points in the tiling, the second specifies the
lines that are projections of the basic lattice vectors in the
four-dimensional hypercubic lattice. The lines are encoded in a sorted
list of integers that refer to the position of the projected points
within the first list."

PlotRadialProjectionDistribution::usage =
"Same as PlotParallelProjection, but applies another radial projection
to the vertices."

PlotParallelProjection::usage =
"PlotParallelProjection[{tilingpoints,tilinglines},linethickness,
psize,pointcolor,linecolor] produces graphics for the tiling specified
by tilingpoints and tilinglines. Here, it is assumed that tilingpoints
comprises a list of the four-dimensional integer coordinates of those
lattice points in the hypercubic lattice that belong to the tiling,
and that tilinglines specifies the lines between points by the
positions of the two endpoints in the list tilingpoints. The remaining
arguments are optional, linethickness determines the width of lines
(default value 1/100), psize the point size (default value 0, i.e., no
points), pointcolor and linecolor the colors of points (default blue)
and lines (default black), respectively. Colors can be specified
either by a single number num, resulting in GrayLevel[num], or by a
list of three of four numbers, in which cases the corresponding RGB or
CMYK color is used, respectively."

PlotOrthogonalProjection::usage =
"PlotOrthogonalProjection[{tilingpoints,tilinglines},linethickness,
psize,pointcolor,linecolor] produces graphics for the projection to
orthogonal space of the tiling specified by tilingpoints and
tilinglines. Here, it is assumed that tilingpoints comprises a list of
the four-dimensional integer coordinates of those lattice points in
the hypercubic lattice that belong to the tiling, and that tilinglines
specifies the lines between points by the positions of the two
endpoints in the list tilingpoints. The projected points and the
acceptance domain are shown. The remaining arguments are optional,
linethickness determines the width of lines (default value 1/100),
psize the point size (default value 1/25), pointcolor and linecolor
the colors of points (default blue) and lines (default black),
respectively. Colors can be specified either by a single number num,
resulting in GrayLevel[num], or by a list of three of four numbers, in
which cases the corresponding RGB or CMYK color is used,
respectively."

CheckProjectionInWindow::usage = 
"CheckProjectionInWindow[pt] determines whether the projection to
orthogonal space of the four-dimensional hypercubic lattice point pt
falls inside the acceptance domain. This is done by comparing the
numerical values of the coordinates. The numerical precision used for
that comparison can be chosen with SetNumericalPrecision."

ShiftWindowCenter::usage =
"ShiftWindowCenter[vec] determines the position of the acceptance
domain by the two-dimensional vector vec. Its default position
corresponds to vec={0,0}, in which case the tiling projected with
OctagonalProjectionTiling shows a perfect eightfold rotational
symmetry about the projection of the lattice point {0,0,0,0} of the
four-dimensional hypercubic lattice."

WindowCenterShift::usage =
"WindowCenterShift is a vector in the two-dimensional orthogonal space 
that determines the position of the acceptance domain. It default value
is {0,0}, it can be changed to any vector v using ShiftWindowCenter[v]."

SetNumericalPrecision::usage =
"SetNumericalPrecision[numprec] replaces the value of NumericalPrecision,
used to compute numerical values for the coordinates of projected points
and check whether these fall into the window or not, by the integer numacc. 
The default value of NumericalPrecision is $MachinePrecision. In practice,
values that are smaller in modulus than NumericalAccuracy, which is set
to 10^(2-NumericalPrecision), are treated as zero, which can produce
wrong results when NumericalPrecision is chosen too small."

NumericalAccuracy::usage =
"NumericalAccuracy is the numerical accuracy used in numerical checks
for the projection in orthogonal space. This means that all values
that are smaller (in modulus) than NumericalAccuracy are assumed to be
exactly zero. The value of NumericalAccuray can be changed by
SetNumericalPrecision[numprec], which sets it to 10^(2-numprec).  Its
default value is 10^(2-$MachinePrecision)."

NumericalPrecision::usage =
"NumericalPrecision is the numerical precision used to compute numerical
values for the coordinates of vertices. Its value can be changed by
SetNumericalPresicion. The default value of NumericalPrecision is
$MachinePrecision."

(********************************************************************)
(*                                                                  *)
(*                   Unprotect exported functions                   *)
(*                                                                  *)
(********************************************************************)

Unprotect[PlotCubeParallelProjection,
          PlotCubeOrthogonalProjection,
          OctagonalProjectionTiling,
          OctagonalProjectionTilingVis,
          PlotRadialProjectionDistribution,
          PlotParallelProjection,
          PlotParallelProjectionAlt,
          PlotOrthogonalProjection,
          NumericalAccuracy,
          NumericalPrecision,
          CheckProjectionInWindow,
          CheckScaledProjInWindow,
          WindowCenterShift,
          ShiftWindowCenter,
          SetNumericalPrecision]

(********************************************************************)
(*                                                                  *)
(*                     Start of Private context                     *)
(*                                                                  *)
(********************************************************************)

Begin["`Private`"]


Clear[SetNumericalPrecision,
      NumericalPrecision,
      NumericalAccuracy,
      SilverMeanLambda,
      InnerOctagonRadiusSquared,
      OuterOctagonRadiusSquared,
      HyperCubicBasis,
      ProjectionVector,
      LatticeToPhysicalMatrix,
      WindowCenter,
      WindowCenterShift,
      ShiftWindowCenter,
      VectorParallelProjection,
      VectorOrthogonalProjection,
      VectorOrthogonalProjectionShift,
      HyperCubeFour, 
      HyperCubeFourEdges,
      PlotCubeParallelProjection,
      PlotCubeOrthogonalProjection,
      PrintNumericalPrecisionWarning,
      CheckProjectionInWindow,
      CheckScaledProjInWindow,
      CheckProjInCircularWindow,
      CheckScaledProjInCircularWindow,
      CheckProjectionInSector,
      OctagonalProjectionTiling,
      OctagonalProjectionTilingVis,
      PlotRadialProjectionDistribution,
      PlotParallelProjection,
      PlotParallelProjectionAlt,
      PlotOrthogonalProjection]


(*************************************************)
(* Numerical Accuracy used for checking purposes *)
(*************************************************)

NumericalPrecision = $MachinePrecision

NumericalAccuracy = 10.^(2 - $MachinePrecision)

SetNumericalPrecision[numprec_Integer] :=
  Module[{},
         Unprotect[NumericalPrecision,NumericalAccuracy];
         NumericalPrecision = numprec;
         NumericalAccuracy = 10.^(2-numprec);
         Protect[NumericalPrecision,NumericalAccuracy];]

(*******************)
(* The silver mean *)
(*******************)

SilverMeanLambda = 
   1 + Sqrt[2]

(***********************************************)
(* Inner and outer radius of acceptance domain *)
(***********************************************)

InnerOctagonRadiusSquared =
   (2*SilverMeanLambda+1)/8

OuterOctagonRadiusSquared =
   (SilverMeanLambda+1)/4

(*********************************************************)
(* This is the radius of the corresponding object if we  *)
(* replace the original (octagonal)                      *)
(* acceptance domain by a circle of equal area.          *)
(* The area is computed by                               *)
(*            A_outer = 2 * Sqrt[2] * R^2                *)
(* or                                                    *)
(*            A_inner = 8 * (Sqrt[2] - 1) * r^2          *)
(* if R (r) is the outer (inner) radius of the octagon.  *)
(*********************************************************) 

ReferenceCircleRadiusSquared =
    SilverMeanLambda/Pi;

(********************************************************)
(* Basis vectors of four-dimensional hypercubic lattice *)
(********************************************************)

HyperCubicBasis[1] = 
   {1,0,0,0}

HyperCubicBasis[2] =
   {0,1,0,0}

HyperCubicBasis[3] =
   {0,0,1,0}

HyperCubicBasis[4] =
   {0,0,0,1}

(********************************)
(* Projections of basis vectors *)
(********************************)

ProjectionVector[1] = 
   Sqrt[2]*{2, Sqrt[2],0,-Sqrt[2]}/4

ProjectionVector[2] = 
   Sqrt[2]*{0, Sqrt[2],2, Sqrt[2]}/4

ProjectionVector[3] = 
   Sqrt[2]*{2,-Sqrt[2],0, Sqrt[2]}/4

ProjectionVector[4] = 
   Sqrt[2]*{0,-Sqrt[2],2,-Sqrt[2]}/4

(*******************************************************************)
(* Parallel and orthogonal projections of four-dimensional vectors *)
(*******************************************************************)

VectorParallelProjection[v_] :=
   {v.ProjectionVector[1],v.ProjectionVector[2]}

VectorOrthogonalProjection[v_] :=
   {v.ProjectionVector[3],v.ProjectionVector[4]}

VectorOrthogonalProjectionShift[v_] :=
   {v.ProjectionVector[3],v.ProjectionVector[4]} - WindowCenterShift

(****************************************************************************)
(* Transformation matrix from lattice (L8) into physical space:             *)
(* Matrix applied to a vector from (4-dimensional) lattice space gives      *)
(* the corresponding projection in physical space in the form               *)
(*         (alpha1, alpha2, beta1, beta2)                                   *)
(* where                                                                    *)
(*        alpha = alpha1 + Sqrt[2] * alpha2,                                *)
(*        beta  = beta1  + Sqrt[2] * beta2,                                 *)
(* and                                                                      *)
(*        alpha * 1 + beta * xi  (xi = Exp[2*Pi*I/8])                       *)
(* is the projected vector in Z[xi] (physical space).                       *)
(* Transformation takes into account that                                   *)
(*        VectorParallelProjection(L8) = Sqrt[2] * Z[xi]                    *)
(* (notice the scaling by Sqrt[2]). This representation can be used to      *)
(* determine visibility of the vector in physical space (by checking        *)
(* Z[Sqrt[2]]-coprimality of alpha and beta.                                *)
(****************************************************************************)

LatticeToPhysicalMatrix =
   {{1, 0, -1, 0},
    {0, 0, 0, -1},
    {0, 1, 0, 1},
    {0, 0, 1, 0}}

(*********************************)
(* Location of acceptance domain *)
(*********************************)

WindowCenter =
   {(SilverMeanLambda-1)/4,(SilverMeanLambda-3)/4}

WindowCenterShift = 
   {0,0}

ShiftWindowCenter[vec_] :=
  Module[{},
         Unprotect[WindowCenterShift];
         WindowCenterShift = vec;
         Protect[WindowCenterShift];]

(**********************************)
(* The four-dimensional hypercube *)
(**********************************)

HyperCubeFour = 
   Flatten[Outer[List,{0,1},{0,1},{0,1},{0,1}],3]

HyperCubeFourEdges  = 
   Module[{i,j},
          Select[Flatten[Table[{HyperCubeFour[[i]],
                                HyperCubeFour[[i]]+HyperCubicBasis[j]},
                              {i,Length[HyperCubeFour]},
                              {j,4}],
                         1],
                 Max[Union[#]]<2&]]

(************************************************************************)
(* Parallel and orthogonal projection of the four-dimensional hypercube *)
(************************************************************************)

HyperCubeParallelProjection =
   Map[VectorParallelProjection,HyperCubeFour]

HyperCubeOrhogonalProjection =
   Map[VectorOrthogonalProjection,HyperCubeFour]

(**********************************************************)
(* Plot parallel projection of four-dimensional hypercube *)
(**********************************************************)

PlotCubeParallelProjection[linethickness_:1/100,
                           psize_:0,
                           pointcolor_:{0,0,1},
                           linecolor_:0] :=
   Module[{plotpoints,
           plotlines,
           color,
           cc},
          color[cc_Integer] := GrayLevel[cc];       
          color[cc_Real] := GrayLevel[cc];
          color[cc_List] := Which[Length[cc]==3,
                                  RGBColor[Apply[Sequence,cc]],
                                  Length[cc]==4,
                                  CMYKColor[Apply[Sequence,cc]],
                                  True,
                                  Print["wrong color specification"];
                                  Return[]];
          plotpoints = If[psize>0,
                          Join[{color[pointcolor],
                                PointSize[psize]},
                               Map[Point[VectorParallelProjection[#]]&,
                                   HyperCubeFour]],
                          {}];
          plotlines  = If[linethickness>0,
                          Join[{color[linecolor],
                                Thickness[linethickness]},
                               Map[Line,
                                   Partition[
                                     Map[VectorParallelProjection,
                                         Flatten[HyperCubeFourEdges,1]],2]]],
                          {}]; 
   Graphics[Join[plotpoints,plotlines],
            AspectRatio -> Automatic,
            PlotRange -> All]]

(************************************************************)
(* Plot orthogonal projection of four-dimensional hypercube *)
(************************************************************)

PlotCubeOrthogonalProjection[linethickness_:1/100,
                             psize_:0,
                             pointcolor_:{0,0,1},
                             linecolor_:0] :=
   Module[{plotpoints,
           plotlines,
           color,
           cc},
          color[cc_Integer] := GrayLevel[cc];       
          color[cc_Real] := GrayLevel[cc];
          color[cc_List] := Which[Length[cc]==3,
                                  RGBColor[Apply[Sequence,cc]],
                                  Length[cc]==4,
                                  CMYKColor[Apply[Sequence,cc]],
                                  True,
                                  Print["wrong color specification"];
                                  Return[]];
          plotpoints = If[psize>0,
                          Join[{color[pointcolor],
                                PointSize[psize]},
                               Map[Point[VectorOrthogonalProjection[#]]&,
                                   HyperCubeFour]],
                          {}];
          plotlines  = If[linethickness>0,
                          Join[{color[linecolor],
                                Thickness[linethickness]},
                               Map[Line,
                                   Partition[
                                     Map[VectorOrthogonalProjection,
                                         Flatten[HyperCubeFourEdges,1]],2]]],
                          {}]; 
   Graphics[Join[plotpoints,plotlines],
            AspectRatio -> Automatic,
            PlotRange -> All]]

(***********************************************************************)
(* Determine whether lattice points project into the acceptance domain *)
(***********************************************************************)

PrintNumericalPrecisionWarning[functionName_] :=
   Module[{},
          Print["Warning: Insufficient accuracy in module ",
                functionName];
          Print["         Result may be wrong!"];
          Print["         To avoid this problem increase ",
                "NumericalPrecision from its current value ",
                NumericalPrecision];
         ]

CheckProjectionInWindow[point_] := 
   Module[{pt=VectorOrthogonalProjectionShift[point],
          pt1},
          pt1 = pt.pt;
          Which[N[InnerOctagonRadiusSquared-pt1,
                  NumericalPrecision] > NumericalAccuracy,
                Return[True],
                N[OuterOctagonRadiusSquared-pt1,
                  NumericalPrecision] < -NumericalAccuracy,
                Return[False],
                True,
                Return[CheckProjectionInSector[pt]]]]

CheckScaledProjInWindow[point_] := 
   Module[{pt=SilverMeanLambda*VectorOrthogonalProjectionShift[point],
          pt1},
          pt1 = pt.pt;
          Which[N[InnerOctagonRadiusSquared-pt1,
                  NumericalPrecision] > NumericalAccuracy,
                Return[True],
                N[OuterOctagonRadiusSquared-pt1,
                  NumericalPrecision] < -NumericalAccuracy,
                Return[False],
                True,
                Return[CheckProjectionInSector[pt]]]]

CheckProjInCircularWindow[point_] := 
   Module[{pt=VectorOrthogonalProjectionShift[point],
          pt1},
          pt1 = pt.pt;
          Which[N[ReferenceCircleRadiusSquared-pt1,
                  NumericalPrecision] > NumericalAccuracy,
                Return[True],
                N[ReferenceCircleRadiusSquared-pt1,
                  NumericalPrecision] < -NumericalAccuracy,
                Return[False],
                True,
                PrintNumericalPrecisionWarning["CheckProjInCircularWindow"];
                Return[False]]]

CheckScaledProjInCircularWindow[point_] := 
   Module[{pt=SilverMeanLambda*VectorOrthogonalProjectionShift[point],
          pt1},
          pt1 = pt.pt;
          Which[N[ReferenceCircleRadiusSquared-pt1,
                  NumericalPrecision] > NumericalAccuracy,
                Return[True],
                N[ReferenceCircleRadiusSquared-pt1,
                  NumericalPrecision] < -NumericalAccuracy,
                Return[False],
                True,
                PrintNumericalPrecisionWarning["CheckProjInCircularWindow"];
                Return[False]]]

CheckProjectionInSector[orthpoint_] :=
   Module[{pt2=Map[Abs,orthpoint],
           tt},
          tt = Min[N[Sqrt[(2*SilverMeanLambda+1)/8]-pt2[[1]],
                     NumericalPrecision],
                   N[Sqrt[(2*SilverMeanLambda+1)/8]-pt2[[2]],
                     NumericalPrecision],
                   N[SilverMeanLambda/2-(pt2[[1]]+pt2[[2]]),
                     NumericalPrecision]];
          Which[tt>NumericalAccuracy,
                Return[True],
                tt<-NumericalAccuracy,
                Return[False],
                tt>=0,
                PrintNumericalPrecisionWarning["CheckProjectionInSector"];
                Return[True],
                True,
                PrintNumericalPrecisionWarning["CheckProjectionInSector"];
                Return[False]]]

(*************************************)
(* Construction of projection tiling *)
(*************************************)

OctagonalProjectionTiling[initpoint_,maxstep_,
                          hypersteps_:{}] :=
   Module[{p,
           nop0=0,
           nop0i=1,
           nop0f=0,
           nop1=1,
           nop1i=1,
           nop1f=1,
           nop2=0,
           nop2i=2,
           nop2f=1,
           hyperstep = Join[NestList[RotateRight,#,3]&[{1,0,0,0}],
                            NestList[RotateRight,#,3]&[{-1,0,0,0}]],
           tilingpoints = {initpoint},
           tilinglines = {},
           i,
           j,
           k,
           pp,
           pos},
          hyperstep = If[hypersteps==={}, hyperstep[[1;;8]], hyperstep[[hypersteps]]];
          If[Not[CheckProjectionInWindow[initpoint]],
             Return[Print["Initial point not in projection window"]]];
          Do[
             Do[
                p = tilingpoints[[i]];
                Do[
                   pp = p+hyperstep[[j]];
                   If[CheckProjectionInWindow[pp],
                      pos = Position[Table[pp,{nop0}]-
                                     Take[tilingpoints,{nop0i,nop0f}],
                                     {0,0,0,0}];
                      If[pos=!={},
                         pos = pos[[1,1]]+nop0i-1;
                         AppendTo[tilinglines,{i,pos}],
                         pos = Position[Table[pp,{nop1}]-
                                        Take[tilingpoints,{nop1i,nop1f}],
                                        {0,0,0,0}];
                         If[pos=!={},
                            pos = pos[[1,1]]+nop1i-1;
                            AppendTo[tilinglines,{i,pos}],
                            pos = Position[Table[pp,{nop2}]-
                                           Take[tilingpoints,{nop2i,nop2f}],
                                           {0,0,0,0}];
                            If[pos=!={},
                               pos = pos[[1,1]]+nop2i-1;
                               AppendTo[tilinglines,{i,pos}],
                               nop2f++;
                               nop2++;
                               AppendTo[tilinglines,{i,nop2f}];
                               AppendTo[tilingpoints,pp]]]]],
                   {j, Length[hyperstep]}],
                {i,nop1i,nop1f}];
             nop0  = nop1;
             nop0i = nop1i;
             nop0f = nop1f;
             nop1  = nop2;
             nop1i = nop2i;
             nop1f = nop2f;
             nop2  = 0;
             nop2i = nop1f+1;
             nop2f = nop1f,
             {maxstep}];
             Print["constructed patch of octagonal tiling with ",
                    Length[tilingpoints]," vertices and ",
                    Length[tilinglines]," bonds"];
             {tilingpoints,tilinglines}];

(*******************************************************************)
(* Construction of visible vertices from the projection tiling:    *)
(* This construct only vertices but no adjacency information.      *)
(* Both a full vertex list and a visible vertex list is returned.  *)
(*******************************************************************)

OctagonalProjectionTilingVis[initpoint_,maxstep_,
                             silent_,
                             onlySector_:True] := 
   Module[{p,
           nop0=0,
           nop0i=1,
           nop0f=0,
           nop1=1,
           nop1i=1,
           nop1f=1,
           nop2=0,
           nop2i=2,
           nop2f=1,
           hyperstep = Join[NestList[RotateRight,#,3]&[{1,0,0,0}],
                            If[Not[onlySector],NestList[RotateRight,#,3]&[{-1,0,0,0}],{}]],
           tilingpoints = {initpoint},
           visiblepoints = {},
           i,
           j,
           pp,
           pos},
          If[Not[CheckProjectionInWindow[initpoint]],
             Return[Print["Initial point not in projection window"]]];
          Do[
             Do[
                p = tilingpoints[[i]];
                Do[
                   pp = p+hyperstep[[j]];
                   If[CheckProjectionInWindow[pp],
                      (* This basically searches for a copy of pp in the tilingpoints list *)
                      (* while restricting the search to the interval [nop0i, nop0f].      *)
                      pos = Position[Table[pp,{nop0}]-
                                     Take[tilingpoints,{nop0i,nop0f}],
                                     {0,0,0,0}];
                      If[pos==={},
                         pos = Position[Table[pp,{nop1}]-
                                        Take[tilingpoints,{nop1i,nop1f}],
                                        {0,0,0,0}];
                         If[pos==={},
                            pos = Position[Table[pp,{nop2}]-
                                           Take[tilingpoints,{nop2i,nop2f}],
                                           {0,0,0,0}];
                            If[pos==={},
                               nop2f++;
                               nop2++;
                               AppendTo[tilingpoints,pp];
                               If[Not[CheckScaledProjInWindow[pp]] &&
                                  CoprimeZ2Alt[LatticeToPhysicalMatrix.pp],
                                  AppendTo[visiblepoints,pp]]]]]],
                   {j,Length[hyperstep]}],
                {i,nop1i,nop1f}];
             nop0  = nop1;
             nop0i = nop1i;
             nop0f = nop1f;
             nop1  = nop2;
             nop1i = nop2i;
             nop1f = nop2f;
             nop2  = 0;
             nop2i = nop1f+1;
             nop2f = nop1f,
             {maxstep}];
             If[Not[silent], Print["constructed patch of octagonal tiling with ",
                                   Length[tilingpoints], " vertices and ",
                                   Length[visiblepoints], " visible ones."]];
             {tilingpoints, visiblepoints}];

(******************************************************)
(* Plot the radial projection distribution of the     *)
(* visible vertices obtained through the              *)
(* OctagonalProjectionTilingVis function.             *)
(******************************************************)

PlotRadialProjectionDistribution[tilingpoints_List,
                                 {CutOff_,Step_}] :=
   Module[{vertices,
           radius,
           radprojections,
           mdist,
           angledists},
          (* Project to physical space and extract single (eighth) sector. *)
          vertices = Select[Map[VectorParallelProjection, tilingpoints],
                            #[[1]]>=0 && #[[2]]>=#[[1]]&];
          (* Compute outer radius of the tiling. *)
          (*radius = Max[Map[
                   Function[x, Max[Map[Part[#, x] &, vertices]]], {1, 2}]];*)
          (* Compute angles of the points, then sort and compute *)
          (* differences between neighbouring angles. *)
          radprojections = Sort[Map[ArcTan[#[[1]], #[[2]]]&, vertices], Greater];
          mdist = (radprojections[[1]] - radprojections[[-1]])/(Length[radprojections] - 1);
          Print["After radial projection and sector extraction ", Length[vertices],
                " datapoints remain."];
          Clear[vertices];
          angledists = Drop[radprojections - RotateLeft[radprojections], -1];
          Clear[radprojections];
          Histogram[angledists/mdist, {0, CutOff, Step}]
]

(**************************************)
(* Plot parallel projection of tiling *)
(**************************************)

PlotParallelProjection[{tilingpoints_List,tilinglines_List},
                       linethickness_:1/100,
                       psize_:0,
                       pointcolor_:{0,0,1},
                       linecolor_:0] :=
   Module[{plotpoints,
           plotlines,
           color,
           cc},
          color[cc_Integer] := GrayLevel[cc];       
          color[cc_Real] := GrayLevel[cc];
          color[cc_List] := Which[Length[cc]==3,
                                  RGBColor[Apply[Sequence,cc]],
                                  Length[cc]==4,
                                  CMYKColor[Apply[Sequence,cc]],
                                  True,
                                  Print["wrong color specification"];
                                  Return[]];
          plotpoints = N[Map[VectorParallelProjection,
                             tilingpoints]];
          plotlines  = tilinglines /. {n_Integer :> Part[plotpoints,n]};
          plotpoints = If[psize>0,
                          Join[{color[pointcolor],
                                PointSize[psize]},
                               Map[Point,plotpoints]],
                          {}];
          plotlines  = If[linethickness>0,
                          Join[{color[linecolor],
                                Thickness[linethickness]},
                               Map[Line,plotlines]],
                          {}];
          Graphics[Join[plotpoints,plotlines],
                   AspectRatio -> Automatic]]

(******************************************)
(* Plot parallel projection of tiling:    *)
(* Alternate version: Only plots points.  *)
(******************************************)

PlotParallelProjectionAlt[tilingpoints_List,
                          psize_:0,
                          pointcolor_:{0,0,1},
                          onlySector_:False] :=
   Module[{plotpoints,
           color,
           cc},
          color[cc_Integer] := GrayLevel[cc];       
          color[cc_Real] := GrayLevel[cc];
          color[cc_List] := Which[Length[cc]==3,
                                  RGBColor[Apply[Sequence,cc]],
                                  Length[cc]==4,
                                  CMYKColor[Apply[Sequence,cc]],
                                  True,
                                  Print["wrong color specification"];
                                  Return[]];
          plotpoints = N[Map[VectorParallelProjection,
                             tilingpoints]];
          If[onlySector, plotpoints = Select[plotpoints, #[[1]]>=0 && #[[2]]>=#[[1]]&]];

          plotpoints = If[psize>0,
                          Join[{color[pointcolor],
                                PointSize[psize]},
                               Map[Point, plotpoints]],
                          {}];
          Graphics[plotpoints,
                   AspectRatio -> Automatic]]

(****************************************)
(* Plot orthogonal projection of tiling *)
(****************************************)

PlotOrthogonalProjection[{tilingpoints_List,tilinglines_List},
                         linethickness_:1/100,
                         psize_:1/25,
                         pointcolor_:{0,0,1},
                         linecolor_:0] :=
   Module[{plotpoints,
           plotlines,
           color,
           cc},
          color[cc_Integer] := GrayLevel[cc];       
          color[cc_Real] := GrayLevel[cc];
          color[cc_List] := Which[Length[cc]==3,
                                  RGBColor[Apply[Sequence,cc]],
                                  Length[cc]==4,
                                  CMYKColor[Apply[Sequence,cc]],
                                  True,
                                  Print["wrong color specification"];
                                  Return[]];
          plotpoints = N[Map[VectorOrthogonalProjectionShift,
                             tilingpoints]];
          plotpoints = If[psize>0,
                          Join[{color[pointcolor],
                                PointSize[psize]},
                               Map[Point,plotpoints]],
                          {}];
          plotlines  = If[linethickness>0,
                          {color[linecolor],
                           Thickness[linethickness],
                           Line[{{-#1,-#2},{-#1, #2},
                                 {-#2, #1},{ #2, #1},
                                 { #1, #2},{ #1,-#2},
                                 { #2,-#1},{-#2,-#1},
                                 {-#1,-#2}}&[N[Sqrt[(2*SilverMeanLambda+1)/8]],
                                             N[(SilverMeanLambda-1)/4]]]},
                          {}];
          Graphics[Join[plotpoints,plotlines],
                   AspectRatio -> Automatic,
                   PlotRange -> All]]


(********************************************************************)
(*                                                                  *)
(*                      End of Private context                      *)
(*                                                                  *)
(********************************************************************)

End[]

(********************************************************************)
(*                                                                  *)
(*                    Protect exported functions                    *)
(*                                                                  *)
(********************************************************************)

Protect[PlotCubeParallelProjection,
        PlotCubeOrthogonalProjection,
        OctagonalProjectionTiling,
        OctagonalProjectionTilingVis,
        PlotRadialProjectionDistribution,
        PlotParallelProjection,
        PlotParallelProjectionAlt,
        PlotOrthogonalProjection,
        NumericalAccuracy,
        NumericalPrecision,
        CheckProjectionInWindow,
        ShiftWindowCenter,
        WindowCenterShift,
        SetNumericalPrecision]

(********************************************************************)
(*                                                                  *)
(*        End of package "AperiodicTilings`OctagonalTilingCP`"        *)
(*                                                                  *)
(********************************************************************)

EndPackage[]

